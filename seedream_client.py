"""
Seedream client wrapper.
Supports sending images as base64 and receives outputs either as URLs or base64 blobs.
CONFIG expects:
{
  "endpoint": "...",
  "api_key_env": "SEEDREAM_API_KEY",
  "default_size": "..."
}
"""
import os
import json
import logging
import requests
from pathlib import Path
from utils import read_binary_as_b64, ensure_dir

logger = logging.getLogger(__name__)

class SeedreamClient:
    def __init__(self, cfg):
        self.endpoint = cfg.get("endpoint")
        self.api_key_env = cfg.get("api_key_env", "SEEDREAM_API_KEY")
        self.api_key = os.getenv(self.api_key_env)
        self.default_size = cfg.get("default_size", "2880*4096")
        self.mode = cfg.get("mode", "http")  # allow 'mock' if desired

    def call(self, image_paths, prompt_text, size=None, sync=True, timeout=120):
        if len(image_paths) != 3:
            raise ValueError("SeedreamClient expects exactly 3 images")
        size = size or self.default_size

        if self.mode == "mock":
            # return a fake structure similar to real API
            return {"data": {"outputs": [ {"b64_json": None, "mock_note": f"mock output for {Path(image_paths[2]).stem}"} ]}}

        if not self.endpoint:
            raise RuntimeError("Seedream endpoint not configured in client")
        if not self.api_key:
            raise RuntimeError("Seedream API key missing in environment")

        imgs_b64 = [read_binary_as_b64(p) for p in image_paths]
        body = {
            "prompt": prompt_text,
            "images": imgs_b64,
            "size": size,
            "enable_sync_mode": sync,
            "enable_base64_output": False
        }
        headers = {"Authorization": f"Bearer {self.api_key}", "Content-Type": "application/json"}
        resp = requests.post(self.endpoint, json=body, headers=headers, timeout=timeout)
        try:
            resp.raise_for_status()
        except requests.HTTPError:
            logger.error("Seedream HTTP error: %s %s", resp.status_code, resp.text)
            raise
        return resp.json()

    def download_output_image(self, output_json, save_dir, index_label):
        data = output_json.get("data") or output_json
        outputs = data.get("outputs") if isinstance(data, dict) else None
        if not outputs:
            # try other shapes
            # sometimes result might be in data[0] etc.
            raise RuntimeError("No outputs found in Seedream response: " + str(output_json)[:200])

        first = outputs[0]
        ensure_dir(save_dir)
        # If string URL
        if isinstance(first, str) and first.startswith("http"):
            r = requests.get(first, timeout=60)
            r.raise_for_status()
            path = os.path.join(save_dir, f"{index_label}.png")
            with open(path, "wb") as f:
                f.write(r.content)
            caption_path = os.path.join(save_dir, f"{index_label}.txt")
            with open(caption_path, "w", encoding="utf-8") as f:
                f.write("Generated by Seedream. source_excerpt:" + str(output_json)[:300])
            return path, caption_path
        # If dict with base64
        if isinstance(first, dict):
            import base64
            # try common key names
            if "b64_json" in first and first["b64_json"]:
                b64 = first["b64_json"]
                data_bytes = base64.b64decode(b64)
            elif "base64" in first and first["base64"]:
                data_bytes = base64.b64decode(first["base64"])
            elif "image" in first and isinstance(first["image"], str):
                data_bytes = base64.b64decode(first["image"])
            else:
                raise RuntimeError("Unknown image container in output: " + str(first)[:200])

            path = os.path.join(save_dir, f"{index_label}.png")
            with open(path, "wb") as f:
                f.write(data_bytes)
            caption_path = os.path.join(save_dir, f"{index_label}.txt")
            with open(caption_path, "w", encoding="utf-8") as f:
                f.write("Generated by Seedream. source_excerpt:" + str(output_json)[:300])
            return path, caption_path

        raise RuntimeError("Unsupported output format from Seedream: " + str(first)[:200])
